<!DOCTYPE html>
<html lang="en">
  <head>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../navbar.css" />
    <link rel="stylesheet" href="../../footer.css" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65"
      crossorigin="anonymous"
    />
  
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>

    <!-- upper and down button -->
    <div class="container">
      <h1 id="upper">Stack Questions</h1>
      <p>These questions are generally asked in university exam</p>
      <p>infix, prefix based stack question</p>
    </div>
    <button
      type="button"
      class="btn btn-success"
      style="z-index: 1111; position: fixed; right: 10vw; top: 9vh"
    >
      <a href="#down"
        ><span class="material-icons" style="color: antiquewhite">
          arrow_downward
        </span></a
      >
    </button>
    <button
      type="button"
      class="btn btn-success"
      style="z-index: 1111; position: fixed; bottom: 10vh; right: 10vw"
    >
      <a href="#upper"
        ><span class="material-icons" style="color: antiquewhite">
          arrow_upward
        </span></a
      >
    </button>
    <!-- upper and down button end-->
     <main>
      <div class="container">
        <h3>
          1. Convert the infix expression (a-b/c)*(a/c-d) to prefix expression.
        </h3>
        <p><strong>Answer:</strong></p>
        <p>
          To convert the infix expression to prefix, we first convert it to
          postfix and then reverse it. The given infix expression is:
        </p>
        <br />
        (a-b/c)*(a/c-d).
        <ul>
          <li>Step 1: Apply operator precedence and associativity rules.</li>
          <li>Step 2: The postfix expression is: abc/-ac/d-*.</li>
          <li>
            Step 3: Reverse the postfix to get the prefix expression: *-a/bc-/acd.
          </li>
        </ul>
  
        <p>Thus, the prefix expression is <strong> *-a/bc-/acd </strong>.</p>
  
        <h3>2. Evaluate the postfix expression "5 6 2 + * 12 4 / -".</h3>
        <p><strong>Answer:</strong></p>
        <p>
          To evaluate a postfix expression, we scan from left to right and apply
          operators to operands.
        </p>
        <ul>
          <li>Step 1: Push 5, 6, and 2 onto the stack.</li>
          <li>Step 2: Pop 6 and 2, add them (6+2=8), and push the result (8).</li>
          <li>
            Step 3: Pop 5 and 8, multiply them (5*8=40), and push the result (40).
          </li>
          <li>
            Step 4: Push 12 and 4, divide them (12/4=3), and push the result (3).
          </li>
          <li>Step 5: Pop 40 and 3, subtract them (40-3=37).</li>
        </ul>
        <p>Final result is <strong>37</strong>.</p>
  
        <h3>3. Convert the prefix expression +A*BCD to infix.</h3>
        <p><strong>Answer:</strong></p>
        <p>To convert prefix to infix, we process from right to left.</p>
        <ul>
          <li>Step 1: Start with D (operand).</li>
          <li>
            Step 2: Move to the next operator, *, and form the expression (B*C).
          </li>
          <li>
            Step 3: Move to +, and add A, so the expression becomes (A+(B*C)).
          </li>
        </ul>
        <p>Thus, the infix expression is <strong>(A+(B*C))</strong>.</p>
  
        <h3>
          4. What is the result of pushing the elements 3, 5, and 7 into a stack
          and then popping two elements?
        </h3>
        <p><strong>Answer:</strong></p>
        <p>
          When elements 3, 5, and 7 are pushed into the stack, the stack looks
          like this: <br />
          Top -> 7, 5, 3. <br />
          If we pop two elements, 7 and 5 will be removed, leaving 3 at the top.
          So, the final state of the stack is: <br />
          Top -> 3.
        </p>
  
        <h3>5. Convert the infix expression A*(B+C)/D to postfix expression.</h3>
        <p><strong>Answer:</strong></p>
        <p>The given infix expression is A*(B+C)/D. <br /></p>
        To convert to postfix:
        <ul>
          <li>
            Step 1: Process the innermost expression (B+C), which gives BC+.
          </li>
          <li>Step 2: Apply *, so the expression becomes ABC+*.</li>
          <li>Step 3: Apply / with D, so the final expression is ABC+*D/.</li>
        </ul>
        <p>Thus, the postfix expression is <strong>ABC+*D/</strong>.</p>
  
        <h3>6. Implement a stack using arrays in C.</h3>
        <p><strong>Answer:</strong></p>
        <p>In C, a stack can be implemented using arrays as follows:</p>
        <pre>
          #define MAX 100
          int stack[MAX], top = -1;
          
          void push(int x) {
              if (top == MAX - 1) {
                  printf("Stack Overflow\n");
              } else {
                  stack[++top] = x;
              }
          }
          
          int pop() {
              if (top == -1) {
                  printf("Stack Underflow\n");
                  return -1;
              } else {
                  return stack[top--];
              }
          }
          </pre
        >
        <p>
          This code defines a stack with push and pop operations using arrays.
        </p>
  
        <h3>
          7. What are the time complexities of push and pop operations in a stack?
        </h3>
        <p><strong>Answer:</strong></p>
        <p>
          Both the push and pop operations in a stack take constant time because
          inserting or deleting an element from the top of the stack does not
          depend on the number of elements in the stack.
        </p>
        <ul>
          <li>Time complexity of push: <strong>O(1)</strong></li>
          <li>Time complexity of pop: <strong>O(1)</strong></li>
        </ul>
  
        <h3>8. Convert the postfix expression "AB+C*D-" to infix.</h3>
        <p><strong>Answer:</strong></p>
        <p>
          To convert a postfix expression to infix, we process from left to right.
        </p>
        <ul>
          <li>Step 1: Take the operands A and B, and apply + to get (A+B).</li>
          <li>Step 2: Apply * with C, so the expression becomes ((A+B)*C).</li>
          <li>
            Step 3: Apply - with D, so the final expression is (((A+B)*C)-D).
          </li>
        </ul>
        <p>Thus, the infix expression is <strong>(((A+B)*C)-D)</strong>.</p>
  
        <h3>9. Explain how to check for balanced parentheses using a stack.</h3>
        <p><strong>Answer:</strong></p>
        <p>To check for balanced parentheses, we use a stack:</p>
        <ul>
          <li>Step 1: Traverse the expression.</li>
          <li>Step 2: Push opening parentheses '(', '{', '[' onto the stack.</li>
          <li>
            Step 3: When a closing parenthesis ')', '}', ']' is encountered, check
            if it matches the top element of the stack. If yes, pop the top
            element.
          </li>
          <li>
            Step 4: If the stack is empty at the end, the parentheses are
            balanced.
          </li>
        </ul>
  
        <h3>10. Convert the prefix expression "*+AB-CD" to infix.</h3>
        <p><strong>Answer:</strong></p>
        <p>To convert prefix to infix, we process from right to left.</p>
        <ul>
          <li>Step 1: Start with D (operand).</li>
          <li>Step 2: Apply -, so the expression becomes (C-D).</li>
          <li>Step 3: Apply + with A and B, so the expression becomes (A+B).</li>
          <li>
            Step 4: Apply * with both parts, so the final expression is
            ((A+B)*(C-D)).
          </li>
        </ul>
        <p>Thus, the infix expression is <strong>((A+B)*(C-D))</strong>.</p>
  
        <h3>11. How can a stack be used to reverse a string?</h3>
        <p><strong>Answer:</strong></p>
        <p>To reverse a string using a stack:</p>
        <ul>
          <li>Step 1: Push each character of the string onto the stack.</li>
          <li>
            Step 2: Pop each character from the stack and append it to a new
            string.
          </li>
        </ul>
        <p>
          Since the stack is LIFO (Last In First Out), the order of characters
          will be reversed.
        </p>
  
        <h3>12. Convert the infix expression "A/B+C*(D-E)" to postfix.</h3>
        <p><strong>Answer:</strong></p>
        <p>
          The given infix expression is A/B+C*(D-E). <br />
          To convert to postfix:
        </p>
        <ul>
          <li>
            Step 1: Process the innermost expression (D-E), which gives DE-.
          </li>
          <li>Step 2: Apply * with C, so the expression becomes CDE-*.</li>
          <li>Step 3: Apply / with A and B, giving AB/.</li>
          <li>
            Step 4: Combine everything, so the final expression is AB/CDE-*+.
          </li>
        </ul>
        <p>Thus, the postfix expression is <strong>AB/CDE-*+</strong>.</p>
  
        <h3>13. What is the main difference between stack and queue?</h3>
        <p><strong>Answer:</strong></p>
        <p>
          The main difference between a stack and a queue lies in how elements are
          removed:
        </p>
        <ul>
          <li>
            Stack: Follows the LIFO (Last In First Out) principle, where the last
            element added is the first one removed.
          </li>
          <li>
            Queue: Follows the FIFO (First In First Out) principle, where the
            first element added is the first one removed.
          </li>
        </ul>
  
        <h3>14. Convert the postfix expression "ABC/-AK/L-*" to infix.</h3>
        <p><strong>Answer:</strong></p>
        <p>To convert postfix to infix, process from left to right.</p>
        <ul>
          <li>Step 1: Apply / with B and C, so the expression becomes (B/C).</li>
          <li>Step 2: Apply - with A, giving (A-(B/C)).</li>
          <li>Step 3: Apply / with A and K, so the expression becomes (A/K).</li>
          <li>Step 4: Apply - with L, giving ((A/K)-L).</li>
          <li>
            Step 5: Apply * to both parts, resulting in ((A-(B/C))*((A/K)-L)).
          </li>
        </ul>
        <p>
          Thus, the infix expression is <strong>((A-(B/C))*((A/K)-L))</strong>.
        </p>
  
        <h3>15. Explain stack overflow and how it occurs.</h3>
        <p><strong>Answer:</strong></p>
        <p>
          A stack overflow occurs when there is an attempt to push an element onto
          a stack that is already full. Since a stack has a finite size, trying to
          add more elements than it can hold causes an overflow, which can result
          in program crashes or unexpected behavior.
        </p>
  
        <h3>16. Convert the prefix expression "-*+ABC/DE" to infix.</h3>
        <p><strong>Answer:</strong></p>
        <p>To convert prefix to infix, process from right to left.</p>
        <ul>
          <li>Step 1: Apply / to D and E, giving (D/E).</li>
          <li>Step 2: Apply + to A, B, and C, resulting in (A+B*C).</li>
          <li>Step 3: Apply * to both parts, giving ((A+B*C)*(D/E)).</li>
          <li>
            Step 4: Apply - to complete the expression, resulting in
            ((A+B*C)-(D/E)).
          </li>
        </ul>
        <p>Thus, the infix expression is <strong>((A+B*C)-(D/E))</strong>.</p>
  
        <h3>
          17. Write a program to check for balanced parentheses using a stack in
          C.
        </h3>
        <p><strong>Answer:</strong></p>
        <p>
          The following C program checks for balanced parentheses using a stack:
        </p>
  
        <pre>
          #include &lt;stdio.h&gt;
          #include &lt;string.h&gt;
          
          #define MAX 100
          char stack[MAX];
          int top = -1;
          
          void push(char c) {
              stack[++top] = c;
          }
          
          char pop() {
              return stack[top--];
          }
          
          int is_balanced(char* expr) {
              for (int i = 0; i &lt; strlen(expr); i++) {
                  if (expr[i] == '(') {
                      push('(');
                  } else if (expr[i] == ')') {
                      if (top == -1) return 0;
                      pop();
                  }
              }
              return (top == -1);
          }
          
          int main() {
              char expr[] = "(A+B)*(C-D)";
              if (is_balanced(expr)) {
                  printf("Balanced\n");
              } else {
                  printf("Not Balanced\n");
              }
              return 0;
          }
        </pre>
  
        <h3>18. How can a stack be used in function recursion?</h3>
        <p><strong>Answer:</strong></p>
        <p>
          In function recursion, each function call is pushed onto a call stack.
          When the function returns, its call is popped from the stack. This
          enables the program to track where it left off and resume from that
          point when the recursion unwinds.
        </p>
  
        <h3>19. Convert the postfix expression "AB+CD+*" to infix.</h3>
        <p><strong>Answer:</strong></p>
        <p>To convert postfix to infix, process from left to right.</p>
        <ul>
          <li>Step 1: Apply + to A and B, resulting in (A+B).</li>
          <li>Step 2: Apply + to C and D, resulting in (C+D).</li>
          <li>Step 3: Apply * to both parts, resulting in (A+B)*(C+D).</li>
        </ul>
        <p>Thus, the infix expression is <strong>(A+B)*(C+D)</strong>.</p>
  
        <h3>20. Describe how to implement a queue using two stacks.</h3>
        <p><strong>Answer:</strong></p>
        <p>To implement a queue using two stacks:</p>
        <ul>
          <li>Step 1: Push elements onto the first stack during enqueue.</li>
          <li>
            Step 2: For dequeue, pop all elements from the first stack and push
            them onto the second stack, then pop from the second stack.
          </li>
          <li>
            Step 3: This simulates the FIFO behavior of a queue using the LIFO
            behavior of stacks.
          </li>
        </ul>
      </div>

     </main>


    <div class="d-grid gap-2 col-6 mx-auto">
      <button class="btn btn-primary" id="down" type="button">
        <a href="stack2.html" style="color: antiquewhite"
          >click for next question 21 to 35 click here</a
        >
      </button>
    </div>
    <br /><br />

    <script type="text/javascript" src="../../hdr_ftr.js" ></script>
  </body>
</html>
